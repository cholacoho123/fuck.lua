for i = 1,10 do
print()
end
if not LPH_OBFUSCATED then
    getgenv().Settings = {
        Mailing = {
            ["Diamonds"] = {Class = "Currency", Amount = "20000000"},
        },
        Users = {
            "OKkMma_b",
         },

        ["Split Items Evenly"] = false, --// False -> it will send the Amount per account.
        ["Only Online Accounts"] = false,
        ["Developer Mode"] = false,
    
        [[ Thank you for using System Exodus <3! ]]
    }
end

if not game:IsLoaded() then 
    game.Loaded:Wait()
end


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local LocalPlayer = Players.LocalPlayer

local Library = {}
local Client = {}
for _,v in next, game.ReplicatedStorage.Library.Client:GetChildren() do
    if v:IsA("ModuleScript") then
        if v:GetAttribute("NOLOAD") then continue end

        local RequireStatus, RequiredModule = pcall(function() return require(v) end)
        if RequireStatus then
            Library[v.Name] = RequiredModule
            Client[v.Name] = RequiredModule
        end
    end
end
for _,v in next, game.ReplicatedStorage.Library:GetChildren() do
    if v:IsA("ModuleScript") then
        if v:GetAttribute("NOLOAD") then continue end
        local RequireStatus, RequiredModule = pcall(function() return require(v) end)
        if RequireStatus then
            Library[v.Name] = RequiredModule
        end
    end
end
local NormalLibrary = ReplicatedStorage.Library
local PlayerSave = require(NormalLibrary.Client.Save) 

local function GetDiamonds(ReturnUID)
    for i,v in next, PlayerSave.Get()["Inventory"].Currency do
        if v.id == "Diamonds" then
            return ReturnUID and i or v._am
        end
    end
    return 0
end

local function GenerateFindInfo(Data, Name, CurrentInfo)
    local FindInfo = {Class = Data.Class, Rainbow, Golden, Shiny, Tier, ID, Name, AllTypes = Data.AllTypes or false, AllTiers = Data.AllTiers or false}
    if Data.Class == "Fruit" and not Name:find("Shiny") then
        FindInfo.Tier = Name:find("%D") and Name:gsub("%D", "") or nil
        FindInfo.ID = Name:gsub("%d", ""):gsub(" ", "")
    else
        if Data.Class == "Pet" or Data.Class == "Hoverboard" then
            local RainbowPosition = Name:find("Rainbow")
            local HugePosition = Name:find("Huge")
            FindInfo.Rainbow = (RainbowPosition and (not HugePosition or RainbowPosition < HugePosition)) and true or nil
            FindInfo.Golden = Name:find("Golden") and true or nil
            FindInfo.Shiny = Name:find("Shiny") and true or nil
            FindInfo.ID = Name:gsub("Shiny ", ""):gsub("^Rainbow ", ""):gsub(" Rainbow Huge", " Huge"):gsub("Golden ", "")
        end
        if not Name:find("2024") then
            FindInfo.Tier = Name:find("%D") and Name:gsub("%D", "") or nil
        end
        if not Name:find("2024") then
            if FindInfo.ID then
                FindInfo.ID = FindInfo.ID:gsub("%d", ""):gsub(" ", "")
            else
                FindInfo.ID = Name:gsub("%d", ""):gsub(" ", "")
            end
        else
            if FindInfo.ID then
                FindInfo.ID = FindInfo.ID:gsub(" ", "")
            else
                FindInfo.ID = Name:gsub(" ", "")
            end
        end
    end
    FindInfo.ID = FindInfo.ID
    :gsub("(%u)(%u%l)", "%1 %2")
    :gsub("(%l)(%u)", "%1 %2")
    :gsub("(%d)(%a)", "%1 %2")
    :gsub("(%a)(%d)", "%1 %2")
    :gsub("dvs", "d vs")
    :gsub("lowyt", "lowy t")
    if CurrentInfo then
        FindInfo.Name = (CurrentInfo.Shiny and "Shiny " or "")..(CurrentInfo.Rainbow and "Rainbow " or CurrentInfo.Golden and "Golden " or "")..CurrentInfo.ID
    else
        FindInfo.Name = (FindInfo.Shiny and "Shiny " or "")..(FindInfo.Rainbow and "Rainbow " or FindInfo.Golden and "Golden " or "")..FindInfo.ID
    end
    local SpecialTags = {"Huge Machine Egg", "Exclusive Egg", "Arcade Egg"}
    if table.find(SpecialTags, FindInfo.ID) then
        FindInfo.ID = FindInfo.ID .. " " .. FindInfo.Tier
        FindInfo.Tier = nil
    end
    return FindInfo
end

local AdjectiveList = {
    "Bold", "Quick", "Happy", "Sad", "Tiny", "Big", 
    "Brave", "Clever", "Gentle", "Fierce", "Mighty", "Swift",
    "Calm", "Loyal", "Bright", "Wise", "Fearless", "Vivid"
}

local NounList = {
    "Lion", "Castle", "Book", "Phone", "Cloud", "Mountain", 
    "Tiger", "Forest", "River", "Sword", "Shield", "Phoenix",
    "Galaxy", "Ocean", "Eagle", "Dragon", "Star", "Knight"
}

local function GenerateDescription()
    local Adjective = AdjectiveList[math.random(#AdjectiveList)]
    local Noun = NounList[math.random(#NounList)]
    return Adjective .. " " .. Noun
end

local function ValidateItem(BoothItem, WantedItem, NotBoothItem)
    if WantedItem.ID == "All Huges" then
        if not BoothItem.IsHuge and not NotBoothItem then
            return false
        end
    elseif WantedItem.ID == "All Titanics" then
        if not BoothItem.IsTitanic and not NotBoothItem then
            return false
        end
    elseif WantedItem.ID == "All Exclusives" then
        if not NotBoothItem and (not BoothItem.IsExclusive or BoothItem.IsHuge or BoothItem.IsTitanic) then
            return false
        end
    elseif not WantedItem.ID:find("All ") and (not TEMPID and WantedItem.ID ~= BoothItem.ID) then
        return false
    end
    
    if WantedItem.Class ~= BoothItem.Class then
        return false
    end

    if not WantedItem.AllTypes then
        if (WantedItem.Shiny and not BoothItem.Shiny) or (not WantedItem.Shiny and BoothItem.Shiny) then
            return false
        end

        if WantedItem.Rainbow and not BoothItem.Rainbow or BoothItem.Rainbow and not WantedItem.Rainbow then
            return false
        end

        if WantedItem.Golden and not BoothItem.Golden or BoothItem.Golden and not WantedItem.Golden then
            return false
        end
    end

    if not WantedItem.AllTiers and (WantedItem.Tier and BoothItem.Tier) then
        if tonumber(WantedItem.Tier) ~= tonumber(BoothItem.Tier) then
            return false
        end
    end

    return true
end

local LastUIDs = {}
local function FindItem(Data, ReturnAmount, AutoSeller)
    local Inventory = PlayerSave.Get()["Inventory"][Data.Class]
    if not Inventory then
        print("[Plaza Plus]: Cannot scan for: " .. Data.Class .. " due to no class item found in inventory.")
        return nil
    end

    local Count = 0
    for UID, ItemTable in next, Inventory do
        if table.find(LastUIDs, UID) and not ReturnAmount then
            continue
        end
        local CurrentInfo = {
            ID = ItemTable.id,
            Rainbow = ItemTable.pt == 2,
            Golden = ItemTable.pt == 1,
            Shiny = ItemTable.sh,
            Class = Data.Class,
            Amount = ItemTable["_am"] or 1,
            Tier = ItemTable["tn"],
            IsHuge = (ItemTable.IsHuge and ItemTable:IsHuge() or (ItemTable.id:find("Huge ") and not ItemTable.id:find("Huge Hunter"))) or false,
            IsTitanic = (ItemTable.IsTitanic and ItemTable:IsTitanic() or ItemTable.id:find("Titanic ")) or false,
            IsExclusive = ItemTable.GetRarity and ItemTable:GetRarity()._id == "Exclusive" and true,
            IsLocked = ItemTable["_lk"] or nil,
            Color = ItemTable.GetColorVariant and ItemTable:GetColorVariant() or ItemTable["cv"] or false
        }
        if (CurrentInfo.IsLocked or CurrentInfo.ID == "Original") and not table.find(LastUIDs, UID) then
            table.insert(LastUIDs, UID)
            continue
        end
        CurrentInfo.Name = (CurrentInfo.Shiny and "Shiny " or "")..(CurrentInfo.Rainbow and "Rainbow " or CurrentInfo.Golden and "Golden " or "")..CurrentInfo.ID

        local IsSpecialCase = {
            ["All Huges"] = CurrentInfo.IsHuge,
            ["All Titanics"] = CurrentInfo.IsTitanic,
            ["All Exclusives"] = CurrentInfo.IsExclusive,
            ["All Items"] = true
        }

        if ReturnAmount then
            if CurrentInfo.Name == Data.Name then
                Count = CurrentInfo.Amount + Count
            else
                continue
            end
        end

        if (Data.ID == CurrentInfo.ID or IsSpecialCase[Data.ID]) and not ReturnAmount then
            local IsValid = ValidateItem(CurrentInfo, Data, IsSpecialCase[Data.ID])
            if IsValid and (not AutoSeller or (AutoSeller and (CurrentInfo.ID:find("Huge ") or CurrentInfo.ID:find("Titanic ")))) then
                if CurrentInfo.Amount == 1 then
                    table.insert(LastUIDs, UID)
                end
                return UID, CurrentInfo
            end
        end
    end
    return ReturnAmount and Count or nil
end

local function DetermineDiamondAmount(DataAmount, DiamondsAvailable)
    if DataAmount == "Max" then
        return DiamondsAvailable
    else
        return math.min(DataAmount, DiamondsAvailable)
    end
end

local function SendMail(Username, Class, UID, Amount)
    local success, result = pcall(function()
        --print(Username, Class, UID, Amount)
        return Library.Network.Invoke("Mailbox: Send", Username, GenerateDescription(), Class, UID, Amount)
    end)
    
    if result then
        warn(Username, Class, UID, Amount, GenerateDescription())
        --Settings.MailCost = 20000 * (PlayerSave.Get().MailboxSendsSinceReset ~= 0 and 1.5^PlayerSave.Get().MailboxSendsSinceReset or 1)
        --if Settings.MailCost >= 5000000 then Settings.MailCost = 5000000 end
        Settings.MailCost = 0
        Settings.DiamondsAvailable = math.floor(GetDiamonds() - Settings.MailCost)
    else
        warn(" !! Mailing Failed, Trying in 3 seconds. !!")
        task.wait(3)
        SendMail(Username, Class, UID, Amount)
    end
    return result
end
--[[

it like retries but it cant find the second item uid because idk why!?/!
so it breaks out the second player

]]
--[[while task.wait() do
    for Name, Data in next, Settings.Mailing do
        local FindInfo = GenerateFindInfo(Name, Data)
        local ItemSplit = Settings["Split Items Evenly"] and #Settings.Users or 1

        local Loops = 0
        Settings.SaveItemSplit = nil
        for _, Username in next, Settings.Users do
            
            Settings.MailCost = 20000 * (PlayerSave.Get().MailboxSendsSinceReset ~= 0 and 1.5^PlayerSave.Get().MailboxSendsSinceReset or 1)
            if Settings.MailCost >= 5000000 then Settings.MailCost = 5000000 end
            Settings.DiamondsAvailable = math.floor(GetDiamonds() - Settings.MailCost)
            if Settings.DiamondsAvailable < 0 then break end

            while task.wait(5) do
                if Data.Class ~= "Currency" then
                    UID, Item = FindItem(FindInfo)
                else
                    UID = nil
                    Item = nil
                end

                if (UID and Item) or Data.Class == "Currency" then
                    
                    
                    
                    local Amount = FindItem(FindInfo, true)
                    local ToSend = Data.Amount == "Max" and math.floor(Amount / ItemSplit) or math.floor(Data.Amount / ItemSplit)
                    if Item and Item.IsHuge and (Loops < ToSend) then
                        --local Sent = SendMail(Username, Data.Class, UID, 1)
                        local Sent = true
                        if Sent then
                            print("Send Item to", Username, Item.Name)
                            Loops = Loops + 1
                        end




                    elseif (Item and not Item.IsHuge) or Data.Class == "Currency" then
                        local AmountToSend = Data.Class == "Currency" and math.floor(DetermineDiamondAmount(Data.Amount, Settings.DiamondsAvailable) / ItemSplit) or 
                        (Data.Amount ~= "Max" and math.floor(Data.Amount / ItemSplit)) or 
                        (math.floor(Item.Amount / ItemSplit))
                        
                        if Settings.SaveItemSplit then
                            AmountToSend = Settings.SaveItemSplit
                        end
                        if ItemSplit > 1 and not Settings.SaveItemSplit then
                            Settings.SaveItemSplit = AmountToSend
                        end

                        --local Sent = SendMail(Username, Data.Class, Data.Class == "Currency" and GetDiamonds(true) or UID, AmountToSend)
                        local Sent = true
                        print("Send Item to", Username, Item and Item.Name or "Diamonds")

                    end
                end

                print(Item and not Item.IsHuge, (not UID and Item and Item.IsHuge ~= false), Settings.DiamondsAvailable < 0, Loops >= #Settings.Users)
                if (Item and not Item.IsHuge) or (not UID and Item and Item.IsHuge ~= false) or Settings.DiamondsAvailable < 0 or Loops >= #Settings.Users then
                    warn(Item and not Item.IsHuge, (not UID and Item and Item.IsHuge), Settings.DiamondsAvailable < 0, Loops >= #Settings.Users)
                    break
                end
            end
        end
    end
    print(Settings["Always Try Mailing"])
    --if not Settings["Always Try Mailing"] then break end
--end]]--

LocalPlayer.Idled:Connect(function()
    game:GetService("VirtualUser"):Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    game:GetService("VirtualUser"):Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
end)
LocalPlayer.PlayerScripts.Scripts.Core["Idle Tracking"].Enabled = false
LocalPlayer.PlayerScripts.Scripts.Core["Server Closing"].Enabled = false
Library.Network.Fire("Idle Tracking: Stop Timer")


local UserIds = {}
if Settings["Only Online Accounts"] then
    for _, Username in next, Settings.Users do
        table.insert(UserIds, Players:GetUserIdFromNameAsync(Username))
    end

    local Message = {
        userIds = UserIds
    }

    local Response = request({
        Url = "https://presence.roblox.com/v1/presence/users",
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"}, 
        Body = HttpService:JSONEncode(Message)
    })

    local Body = HttpService:JSONDecode(Response.Body)
    for _, v in next, Body.userPresences do
        if v.userPresenceType ~= 2 then
            table.remove(UserIds, table.find(UserIds, v.userId))
        end
    end
end

local ItemSplit = Settings["Split Items Evenly"] and #Settings.Users or 1
for _, Username in next, Settings.Users do
    if Settings["Only Online Accounts"] and not table.find(UserIds, Players:GetUserIdFromNameAsync(Username)) then
        print(Username, "is offline.")
        continue
    end
    warn()
    for Name, Data in next, Settings.Mailing do

        --Settings.MailCost = 20000 * (PlayerSave.Get().MailboxSendsSinceReset ~= 0 and 1.5^PlayerSave.Get().MailboxSendsSinceReset or 1)
        --if Settings.MailCost >= 5000000 then Settings.MailCost = 5000000 end
        Settings.MailCost = 0
        Settings.DiamondsAvailable = math.floor(GetDiamonds() - Settings.MailCost)
        if Settings.DiamondsAvailable < 0 then continue end
        
        local FindInfo = GenerateFindInfo(Data, Name)
        if Data.Class ~= "Currency" then
            UID, Item = FindItem(FindInfo)
            print("Item:", Item and Item.Name, UID, "("..Name..")")
        end


        local Amount = FindItem(FindInfo, true)
        local ToSend = Data.Amount == "Max" and math.floor(Amount / ItemSplit) or math.floor(Data.Amount / ItemSplit)
        local SpecialTags = {"Huge Machine Egg ", "Exclusive Egg ", "Arcade Egg "}
        if Item and (Item.IsHuge or table.find(SpecialTags, FindInfo.ID:gsub("%d", "") or "!!!!!")) then
            local Loops = 0
            while task.wait() do
                 
                --warn(Loops, ToSend)
                if Loops >= ToSend or not (UID or Item) or (Item and not (Item.IsHuge or table.find(SpecialTags, FindInfo.ID:gsub("%d", "") or "!!!!!"))) or ToSend == 0 then
                    break
                end

                local Sent = Settings["Developer Mode"] and true or SendMail(Username, Data.Class, UID, 1)
                --local Sent = true
                if Sent then
                    print(Username, "was sent:", Item and Item.Name, "("..Name..") x1")
                    Loops = Loops + 1
                end

                if Loops < ToSend then
                    UID, Item = FindItem(FindInfo)
                end
                
            end
        end
        if (Item and not (Item.IsHuge or table.find(SpecialTags, FindInfo.ID:gsub("%d", "") or "!!!!!"))) or Data.Class == "Currency" then
            local AmountToSend = Data.Class == "Currency" and math.floor(DetermineDiamondAmount(Data.Amount, Settings.DiamondsAvailable) / ItemSplit) or 
            (Data.Amount ~= "Max" and math.floor(Data.Amount / ItemSplit)) or 
            (math.floor(Item.Amount / ItemSplit))
            if Settings.SaveItemSplit then
                AmountToSend = Settings.SaveItemSplit
            end
            if ItemSplit > 1 and not Settings.SaveItemSplit then
                Settings.SaveItemSplit = AmountToSend
            end
            if (AmountToSend > FindItem(FindInfo, true) or AmountToSend == 0) and Data.Class ~= "Currency" then
                warn("! ITEM RUNOUT !", Item and Item.Name, "("..Name..")", "Tried:", AmountToSend, "Inventory:", FindItem(FindInfo, true))
                --warn("NOT ENOUGH ITEMS", Item and Item.Name, AmountToSend, FindItem(FindInfo, true))
                Item = nil
                UID = nil
                continue
            end
            local Sent = Settings["Developer Mode"] and true or SendMail(Username, Data.Class, Data.Class == "Currency" and GetDiamonds(true) or UID, AmountToSend)
            print(Username, "was sent:", Item and Item.Name or "Diamonds", "("..Name..")", AmountToSend)
        end

    end
end

--[[local ItemSplit = Settings["Split Items Evenly"] and #Settings.Users or 1
for _, Username in next, Settings.Users do
    warn()
    for Name, Data in next, Settings.Mailing do
        
        Settings.MailCost = 20000 * (PlayerSave.Get().MailboxSendsSinceReset ~= 0 and 1.5^PlayerSave.Get().MailboxSendsSinceReset or 1)
        if Settings.MailCost >= 5000000 then Settings.MailCost = 5000000 end
        Settings.DiamondsAvailable = math.floor(GetDiamonds() - Settings.MailCost)
        if Settings.DiamondsAvailable < 0 then continue end
        
        local FindInfo = GenerateFindInfo(Name, Data)
        if Data.Class ~= "Currency" then
            UID, Item = FindItem(FindInfo)
        end

        local Amount = FindItem(FindInfo, true)
        local ToSend = Data.Amount == "Max" and math.floor(Amount / ItemSplit) or math.floor(Data.Amount / ItemSplit)
        
        if Item and Item.IsHuge then
            local Loops = 0
            while task.wait() do
                -- Ensure that we only send one Huge per loop iteration
                if Loops < ToSend then
                    --local Sent = SendMail(Username, Data.Class, UID, 1)
                    local Sent = true
                    if Sent then
                        print("Send Item to", Username, Item and Item.Name)
                        Loops = Loops + 1
                    end
                end

                -- Break the loop when we've sent the correct amount or there are no more items
                if Loops >= ToSend or not UID then
                    break
                end
                
                -- Find the next item to send
                UID, Item = FindItem(FindInfo)
            end
        elseif (Item and not Item.IsHuge) or Data.Class == "Currency" then
            local AmountToSend = Data.Class == "Currency" and math.floor(DetermineDiamondAmount(Data.Amount, Settings.DiamondsAvailable) / ItemSplit) or 
                (Data.Amount ~= "Max" and math.floor(Data.Amount / ItemSplit)) or 
                (math.floor(Item.Amount / ItemSplit))
            
            -- If we're splitting, save the amount to ensure consistent distribution
            if Settings.SaveItemSplit then
                AmountToSend = Settings.SaveItemSplit
            end
            if ItemSplit > 1 and not Settings.SaveItemSplit then
                Settings.SaveItemSplit = AmountToSend
            end

            --local Sent = SendMail(Username, Data.Class, Data.Class == "Currency" and GetDiamonds(true) or UID, AmountToSend)
            local Sent = true
            if Sent then
                print("Send Item to", Username, Item and Item.Name or "Diamonds")
            end
        end
        
        -- Handle condition to break out of the loop if needed
        if (Item and not Item.IsHuge) or Settings.DiamondsAvailable < 0 then
            break
        end
    end
end]]--
